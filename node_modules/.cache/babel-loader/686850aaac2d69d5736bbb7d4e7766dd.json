{"ast":null,"code":";\n\n(function (global) {\n  var lastId = -1; // Visibility.js allow you to know, that your web page is in the background\n  // tab and thus not visible to the user. This library is wrap under\n  // Page Visibility API. It fix problems with different vendor prefixes and\n  // add high-level useful functions.\n\n  var self = {\n    // Call callback only when page become to visible for user or\n    // call it now if page is visible now or Page Visibility API\n    // doesn’t supported.\n    //\n    // Return false if API isn’t supported, true if page is already visible\n    // or listener ID (you can use it in `unbind` method) if page isn’t\n    // visible now.\n    //\n    //   Visibility.onVisible(function () {\n    //       startIntroAnimation();\n    //   });\n    onVisible: function (callback) {\n      var support = self.isSupported();\n\n      if (!support || !self.hidden()) {\n        callback();\n        return support;\n      }\n\n      var listener = self.change(function (e, state) {\n        if (!self.hidden()) {\n          self.unbind(listener);\n          callback();\n        }\n      });\n      return listener;\n    },\n    // Call callback when visibility will be changed. First argument for\n    // callback will be original event object, second will be visibility\n    // state name.\n    //\n    // Return listener ID to unbind listener by `unbind` method.\n    //\n    // If Page Visibility API doesn’t supported method will be return false\n    // and callback never will be called.\n    //\n    //   Visibility.change(function(e, state) {\n    //       Statistics.visibilityChange(state);\n    //   });\n    //\n    // It is just proxy to `visibilitychange` event, but use vendor prefix.\n    change: function (callback) {\n      if (!self.isSupported()) {\n        return false;\n      }\n\n      lastId += 1;\n      var number = lastId;\n      self._callbacks[number] = callback;\n\n      self._listen();\n\n      return number;\n    },\n    // Remove `change` listener by it ID.\n    //\n    //   var id = Visibility.change(function(e, state) {\n    //       firstChangeCallback();\n    //       Visibility.unbind(id);\n    //   });\n    unbind: function (id) {\n      delete self._callbacks[id];\n    },\n    // Call `callback` in any state, expect “prerender”. If current state\n    // is “prerender” it will wait until state will be changed.\n    // If Page Visibility API doesn’t supported, it will call `callback`\n    // immediately.\n    //\n    // Return false if API isn’t supported, true if page is already after\n    // prerendering or listener ID (you can use it in `unbind` method)\n    // if page is prerended now.\n    //\n    //   Visibility.afterPrerendering(function () {\n    //       Statistics.countVisitor();\n    //   });\n    afterPrerendering: function (callback) {\n      var support = self.isSupported();\n      var prerender = 'prerender';\n\n      if (!support || prerender != self.state()) {\n        callback();\n        return support;\n      }\n\n      var listener = self.change(function (e, state) {\n        if (prerender != state) {\n          self.unbind(listener);\n          callback();\n        }\n      });\n      return listener;\n    },\n    // Return true if page now isn’t visible to user.\n    //\n    //   if ( !Visibility.hidden() ) {\n    //       VideoPlayer.play();\n    //   }\n    //\n    // It is just proxy to `document.hidden`, but use vendor prefix.\n    hidden: function () {\n      return !!(self._doc.hidden || self._doc.webkitHidden);\n    },\n    // Return visibility state: 'visible', 'hidden' or 'prerender'.\n    //\n    //   if ( 'prerender' == Visibility.state() ) {\n    //       Statistics.pageIsPrerendering();\n    //   }\n    //\n    // Don’t use `Visibility.state()` to detect, is page visible, because\n    // visibility states can extend in next API versions.\n    // Use more simpler and general `Visibility.hidden()` for this cases.\n    //\n    // It is just proxy to `document.visibilityState`, but use\n    // vendor prefix.\n    state: function () {\n      return self._doc.visibilityState || self._doc.webkitVisibilityState || 'visible';\n    },\n    // Return true if browser support Page Visibility API.\n    // refs: https://developer.mozilla.org/en-US/docs/Web/API/Page_Visibility_API\n    //\n    //   if ( Visibility.isSupported() ) {\n    //       Statistics.startTrackingVisibility();\n    //       Visibility.change(function(e, state)) {\n    //           Statistics.trackVisibility(state);\n    //       });\n    //   }\n    isSupported: function () {\n      return self._doc.hidden !== undefined || self._doc.webkitHidden !== undefined;\n    },\n    // Link to document object to change it in tests.\n    _doc: document || {},\n    // Callbacks from `change` method, that wait visibility changes.\n    _callbacks: {},\n    // Listener for `visibilitychange` event.\n    _change: function (event) {\n      var state = self.state();\n\n      for (var i in self._callbacks) {\n        self._callbacks[i].call(self._doc, event, state);\n      }\n    },\n    // Set listener for `visibilitychange` event.\n    _listen: function () {\n      if (self._init) {\n        return;\n      }\n\n      var event = 'visibilitychange';\n\n      if (self._doc.webkitVisibilityState) {\n        event = 'webkit' + event;\n      }\n\n      var listener = function () {\n        self._change.apply(self, arguments);\n      };\n\n      if (self._doc.addEventListener) {\n        self._doc.addEventListener(event, listener);\n      } else {\n        self._doc.attachEvent(event, listener);\n      }\n\n      self._init = true;\n    }\n  };\n\n  if (typeof module != 'undefined' && module.exports) {\n    module.exports = self;\n  } else {\n    global.Visibility = self;\n  }\n})(this);","map":{"version":3,"sources":["/Users/tommysuh/Desktop/WebDeisgn/creative-project-adam-esther-tommy/node_modules/visibilityjs/lib/visibility.core.js"],"names":["global","lastId","self","onVisible","callback","support","isSupported","hidden","listener","change","e","state","unbind","number","_callbacks","_listen","id","afterPrerendering","prerender","_doc","webkitHidden","visibilityState","webkitVisibilityState","undefined","document","_change","event","i","call","_init","apply","arguments","addEventListener","attachEvent","module","exports","Visibility"],"mappings":"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","sourcesContent":[";(function (global) {\n    var lastId = -1;\n\n    // Visibility.js allow you to know, that your web page is in the background\n    // tab and thus not visible to the user. This library is wrap under\n    // Page Visibility API. It fix problems with different vendor prefixes and\n    // add high-level useful functions.\n    var self = {\n\n        // Call callback only when page become to visible for user or\n        // call it now if page is visible now or Page Visibility API\n        // doesn’t supported.\n        //\n        // Return false if API isn’t supported, true if page is already visible\n        // or listener ID (you can use it in `unbind` method) if page isn’t\n        // visible now.\n        //\n        //   Visibility.onVisible(function () {\n        //       startIntroAnimation();\n        //   });\n        onVisible: function (callback) {\n            var support = self.isSupported();\n            if ( !support || !self.hidden() ) {\n                callback();\n                return support;\n            }\n\n            var listener = self.change(function (e, state) {\n                if ( !self.hidden() ) {\n                    self.unbind(listener);\n                    callback();\n                }\n            });\n            return listener;\n        },\n\n        // Call callback when visibility will be changed. First argument for\n        // callback will be original event object, second will be visibility\n        // state name.\n        //\n        // Return listener ID to unbind listener by `unbind` method.\n        //\n        // If Page Visibility API doesn’t supported method will be return false\n        // and callback never will be called.\n        //\n        //   Visibility.change(function(e, state) {\n        //       Statistics.visibilityChange(state);\n        //   });\n        //\n        // It is just proxy to `visibilitychange` event, but use vendor prefix.\n        change: function (callback) {\n            if ( !self.isSupported() ) {\n                return false;\n            }\n            lastId += 1;\n            var number = lastId;\n            self._callbacks[number] = callback;\n            self._listen();\n            return number;\n        },\n\n        // Remove `change` listener by it ID.\n        //\n        //   var id = Visibility.change(function(e, state) {\n        //       firstChangeCallback();\n        //       Visibility.unbind(id);\n        //   });\n        unbind: function (id) {\n            delete self._callbacks[id];\n        },\n\n        // Call `callback` in any state, expect “prerender”. If current state\n        // is “prerender” it will wait until state will be changed.\n        // If Page Visibility API doesn’t supported, it will call `callback`\n        // immediately.\n        //\n        // Return false if API isn’t supported, true if page is already after\n        // prerendering or listener ID (you can use it in `unbind` method)\n        // if page is prerended now.\n        //\n        //   Visibility.afterPrerendering(function () {\n        //       Statistics.countVisitor();\n        //   });\n        afterPrerendering: function (callback) {\n            var support   = self.isSupported();\n            var prerender = 'prerender';\n\n            if ( !support || prerender != self.state() ) {\n                callback();\n                return support;\n            }\n\n            var listener = self.change(function (e, state) {\n                if ( prerender != state ) {\n                    self.unbind(listener);\n                    callback();\n                }\n            });\n            return listener;\n        },\n\n        // Return true if page now isn’t visible to user.\n        //\n        //   if ( !Visibility.hidden() ) {\n        //       VideoPlayer.play();\n        //   }\n        //\n        // It is just proxy to `document.hidden`, but use vendor prefix.\n        hidden: function () {\n            return !!(self._doc.hidden || self._doc.webkitHidden);\n        },\n\n        // Return visibility state: 'visible', 'hidden' or 'prerender'.\n        //\n        //   if ( 'prerender' == Visibility.state() ) {\n        //       Statistics.pageIsPrerendering();\n        //   }\n        //\n        // Don’t use `Visibility.state()` to detect, is page visible, because\n        // visibility states can extend in next API versions.\n        // Use more simpler and general `Visibility.hidden()` for this cases.\n        //\n        // It is just proxy to `document.visibilityState`, but use\n        // vendor prefix.\n        state: function () {\n            return self._doc.visibilityState       ||\n                   self._doc.webkitVisibilityState ||\n                   'visible';\n        },\n\n        // Return true if browser support Page Visibility API.\n        // refs: https://developer.mozilla.org/en-US/docs/Web/API/Page_Visibility_API\n        //\n        //   if ( Visibility.isSupported() ) {\n        //       Statistics.startTrackingVisibility();\n        //       Visibility.change(function(e, state)) {\n        //           Statistics.trackVisibility(state);\n        //       });\n        //   }\n        isSupported: function () {\n            return self._doc.hidden !== undefined || self._doc.webkitHidden !== undefined;\n        },\n\n        // Link to document object to change it in tests.\n        _doc: document || {},\n\n        // Callbacks from `change` method, that wait visibility changes.\n        _callbacks: { },\n\n        // Listener for `visibilitychange` event.\n        _change: function(event) {\n            var state = self.state();\n\n            for ( var i in self._callbacks ) {\n                self._callbacks[i].call(self._doc, event, state);\n            }\n        },\n\n        // Set listener for `visibilitychange` event.\n        _listen: function () {\n            if ( self._init ) {\n                return;\n            }\n\n            var event = 'visibilitychange';\n            if ( self._doc.webkitVisibilityState ) {\n                event = 'webkit' + event;\n            }\n\n            var listener = function () {\n                self._change.apply(self, arguments);\n            };\n            if ( self._doc.addEventListener ) {\n                self._doc.addEventListener(event, listener);\n            } else {\n                self._doc.attachEvent(event, listener);\n            }\n            self._init = true;\n        }\n\n    };\n\n    if ( typeof(module) != 'undefined' && module.exports ) {\n        module.exports = self;\n    } else {\n        global.Visibility = self;\n    }\n\n})(this);\n"]},"metadata":{},"sourceType":"script"}