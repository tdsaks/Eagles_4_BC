{"ast":null,"code":"/*\n * JavaScript Load Image IPTC Parser\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2013, Sebastian Tschan\n * Copyright 2018, Dave Bevan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, module, require, Buffer */\n;\n\n(function (factory) {\n  'use strict';\n\n  if (typeof define === 'function' && define.amd) {\n    // Register as an anonymous AMD module:\n    define(['./load-image', './load-image-meta'], factory);\n  } else if (typeof module === 'object' && module.exports) {\n    factory(require('./load-image'), require('./load-image-meta'));\n  } else {\n    // Browser globals:\n    factory(window.loadImage);\n  }\n})(function (loadImage) {\n  'use strict';\n\n  loadImage.IptcMap = function () {\n    return this;\n  };\n\n  loadImage.IptcMap.prototype.map = {\n    ObjectName: 0x5\n  };\n\n  loadImage.IptcMap.prototype.get = function (id) {\n    return this[id] || this[this.map[id]];\n  };\n\n  loadImage.parseIptcTags = function (dataView, startOffset, sectionLength, data) {\n    /**\n     * Retrieves string for the given Buffer and range\n     *\n     * @param {Buffer} buffer IPTC buffer\n     * @param {number} start Range start\n     * @param {number} length Range length\n     * @returns {string} String value\n     */\n    function getStringFromDB(buffer, start, length) {\n      var outstr = '';\n\n      for (var n = start; n < start + length; n++) {\n        outstr += String.fromCharCode(buffer.getUint8(n));\n      }\n\n      return outstr;\n    }\n\n    var fieldValue, dataSize, segmentType;\n    var segmentStartPos = startOffset;\n\n    while (segmentStartPos < startOffset + sectionLength) {\n      // we currently handle the 2: class of iptc tag\n      if (dataView.getUint8(segmentStartPos) === 0x1c && dataView.getUint8(segmentStartPos + 1) === 0x02) {\n        segmentType = dataView.getUint8(segmentStartPos + 2); // only store data for known tags\n\n        if (segmentType in data.iptc.tags) {\n          dataSize = dataView.getInt16(segmentStartPos + 3);\n          fieldValue = getStringFromDB(dataView, segmentStartPos + 5, dataSize); // Check if we already stored a value with this name\n\n          if (Object.prototype.hasOwnProperty.call(data.iptc, segmentType)) {\n            // Value already stored with this name, create multivalue field\n            if (data.iptc[segmentType] instanceof Array) {\n              data.iptc[segmentType].push(fieldValue);\n            } else {\n              data.iptc[segmentType] = [data.iptc[segmentType], fieldValue];\n            }\n          } else {\n            data.iptc[segmentType] = fieldValue;\n          }\n        }\n      }\n\n      segmentStartPos++;\n    }\n  };\n\n  loadImage.parseIptcData = function (dataView, offset, length, data, options) {\n    if (options.disableIptc) {\n      return;\n    }\n\n    var markerLength = offset + length; // Found '8BIM<EOT><EOT>' ?\n\n    var isFieldSegmentStart = function (dataView, offset) {\n      return dataView.getUint32(offset) === 0x3842494d && dataView.getUint16(offset + 4) === 0x0404;\n    }; // Hunt forward, looking for the correct IPTC block signature:\n    // Reference: https://metacpan.org/pod/distribution/Image-MetaData-JPEG/lib/Image/MetaData/JPEG/Structures.pod#Structure-of-a-Photoshop-style-APP13-segment\n    // From https://github.com/exif-js/exif-js/blob/master/exif.js ~ line 474 on\n\n\n    while (offset + 8 < markerLength) {\n      if (isFieldSegmentStart(dataView, offset)) {\n        var nameHeaderLength = dataView.getUint8(offset + 7);\n        if (nameHeaderLength % 2 !== 0) nameHeaderLength += 1; // Check for pre photoshop 6 format\n\n        if (nameHeaderLength === 0) {\n          // Always 4\n          nameHeaderLength = 4;\n        }\n\n        var startOffset = offset + 8 + nameHeaderLength;\n\n        if (startOffset > markerLength) {\n          // eslint-disable-next-line no-console\n          console.log('Invalid IPTC data: Invalid segment offset.');\n          break;\n        }\n\n        var sectionLength = dataView.getUint16(offset + 6 + nameHeaderLength);\n\n        if (offset + sectionLength > markerLength) {\n          // eslint-disable-next-line no-console\n          console.log('Invalid IPTC data: Invalid segment size.');\n          break;\n        } // Create the iptc object to store the tags:\n\n\n        data.iptc = new loadImage.IptcMap(); // Parse the tags\n\n        return loadImage.parseIptcTags(dataView, startOffset, sectionLength, data);\n      } // eslint-disable-next-line no-param-reassign\n\n\n      offset++;\n    } // eslint-disable-next-line no-console\n\n\n    console.log('No IPTC data at this offset - could be XMP');\n  }; // Registers this IPTC parser for the APP13 JPEG meta data segment:\n\n\n  loadImage.metaDataParsers.jpeg[0xffed].push(loadImage.parseIptcData); // Adds the following properties to the parseMetaData callback data:\n  // * iptc: The iptc tags, parsed by the parseIptcData method\n  // Adds the following options to the parseMetaData method:\n  // * disableIptc: Disables IPTC parsing.\n});","map":{"version":3,"sources":["/Users/tommysuh/Desktop/WebDeisgn/creative-project-adam-esther-tommy/node_modules/blueimp-load-image/js/load-image-iptc.js"],"names":["factory","define","amd","module","exports","require","window","loadImage","IptcMap","prototype","map","ObjectName","get","id","parseIptcTags","dataView","startOffset","sectionLength","data","getStringFromDB","buffer","start","length","outstr","n","String","fromCharCode","getUint8","fieldValue","dataSize","segmentType","segmentStartPos","iptc","tags","getInt16","Object","hasOwnProperty","call","Array","push","parseIptcData","offset","options","disableIptc","markerLength","isFieldSegmentStart","getUint32","getUint16","nameHeaderLength","console","log","metaDataParsers","jpeg"],"mappings":"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","sourcesContent":["/*\n * JavaScript Load Image IPTC Parser\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2013, Sebastian Tschan\n * Copyright 2018, Dave Bevan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, module, require, Buffer */\n\n;(function (factory) {\n  'use strict'\n  if (typeof define === 'function' && define.amd) {\n    // Register as an anonymous AMD module:\n    define(['./load-image', './load-image-meta'], factory)\n  } else if (typeof module === 'object' && module.exports) {\n    factory(require('./load-image'), require('./load-image-meta'))\n  } else {\n    // Browser globals:\n    factory(window.loadImage)\n  }\n})(function (loadImage) {\n  'use strict'\n\n  loadImage.IptcMap = function () {\n    return this\n  }\n\n  loadImage.IptcMap.prototype.map = {\n    ObjectName: 0x5\n  }\n\n  loadImage.IptcMap.prototype.get = function (id) {\n    return this[id] || this[this.map[id]]\n  }\n\n  loadImage.parseIptcTags = function (\n    dataView,\n    startOffset,\n    sectionLength,\n    data\n  ) {\n    /**\n     * Retrieves string for the given Buffer and range\n     *\n     * @param {Buffer} buffer IPTC buffer\n     * @param {number} start Range start\n     * @param {number} length Range length\n     * @returns {string} String value\n     */\n    function getStringFromDB(buffer, start, length) {\n      var outstr = ''\n      for (var n = start; n < start + length; n++) {\n        outstr += String.fromCharCode(buffer.getUint8(n))\n      }\n      return outstr\n    }\n    var fieldValue, dataSize, segmentType\n    var segmentStartPos = startOffset\n    while (segmentStartPos < startOffset + sectionLength) {\n      // we currently handle the 2: class of iptc tag\n      if (\n        dataView.getUint8(segmentStartPos) === 0x1c &&\n        dataView.getUint8(segmentStartPos + 1) === 0x02\n      ) {\n        segmentType = dataView.getUint8(segmentStartPos + 2)\n        // only store data for known tags\n        if (segmentType in data.iptc.tags) {\n          dataSize = dataView.getInt16(segmentStartPos + 3)\n          fieldValue = getStringFromDB(dataView, segmentStartPos + 5, dataSize)\n          // Check if we already stored a value with this name\n          if (Object.prototype.hasOwnProperty.call(data.iptc, segmentType)) {\n            // Value already stored with this name, create multivalue field\n            if (data.iptc[segmentType] instanceof Array) {\n              data.iptc[segmentType].push(fieldValue)\n            } else {\n              data.iptc[segmentType] = [data.iptc[segmentType], fieldValue]\n            }\n          } else {\n            data.iptc[segmentType] = fieldValue\n          }\n        }\n      }\n      segmentStartPos++\n    }\n  }\n\n  loadImage.parseIptcData = function (dataView, offset, length, data, options) {\n    if (options.disableIptc) {\n      return\n    }\n    var markerLength = offset + length\n    // Found '8BIM<EOT><EOT>' ?\n    var isFieldSegmentStart = function (dataView, offset) {\n      return (\n        dataView.getUint32(offset) === 0x3842494d &&\n        dataView.getUint16(offset + 4) === 0x0404\n      )\n    }\n    // Hunt forward, looking for the correct IPTC block signature:\n    // Reference: https://metacpan.org/pod/distribution/Image-MetaData-JPEG/lib/Image/MetaData/JPEG/Structures.pod#Structure-of-a-Photoshop-style-APP13-segment\n    // From https://github.com/exif-js/exif-js/blob/master/exif.js ~ line 474 on\n    while (offset + 8 < markerLength) {\n      if (isFieldSegmentStart(dataView, offset)) {\n        var nameHeaderLength = dataView.getUint8(offset + 7)\n        if (nameHeaderLength % 2 !== 0) nameHeaderLength += 1\n        // Check for pre photoshop 6 format\n        if (nameHeaderLength === 0) {\n          // Always 4\n          nameHeaderLength = 4\n        }\n        var startOffset = offset + 8 + nameHeaderLength\n        if (startOffset > markerLength) {\n          // eslint-disable-next-line no-console\n          console.log('Invalid IPTC data: Invalid segment offset.')\n          break\n        }\n        var sectionLength = dataView.getUint16(offset + 6 + nameHeaderLength)\n        if (offset + sectionLength > markerLength) {\n          // eslint-disable-next-line no-console\n          console.log('Invalid IPTC data: Invalid segment size.')\n          break\n        }\n        // Create the iptc object to store the tags:\n        data.iptc = new loadImage.IptcMap()\n        // Parse the tags\n        return loadImage.parseIptcTags(\n          dataView,\n          startOffset,\n          sectionLength,\n          data\n        )\n      }\n      // eslint-disable-next-line no-param-reassign\n      offset++\n    }\n    // eslint-disable-next-line no-console\n    console.log('No IPTC data at this offset - could be XMP')\n  }\n\n  // Registers this IPTC parser for the APP13 JPEG meta data segment:\n  loadImage.metaDataParsers.jpeg[0xffed].push(loadImage.parseIptcData)\n\n  // Adds the following properties to the parseMetaData callback data:\n  // * iptc: The iptc tags, parsed by the parseIptcData method\n\n  // Adds the following options to the parseMetaData method:\n  // * disableIptc: Disables IPTC parsing.\n})\n"]},"metadata":{},"sourceType":"script"}